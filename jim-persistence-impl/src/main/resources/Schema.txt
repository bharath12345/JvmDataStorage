*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
Store the CQL equivalent of all tables in this file
Author: Bharadwaj N
Date: 28th June 2013
Reviewer: Sumanth N

Table of Contents
-----------------

    1. Brief Description
    2. Keyspace
    3. Tables (Column Families)
        3.1 JvmMetrics
            - Description
            - Queries
        3.2 JvmThreadMetrics

        3.3 JvmMemoryMetrics
        3.4 JvmDataSourceMetrics
        3.4 JvmMethodMetrics

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

1. Brief Description
        * Every keyspace holds Raw and Roll-up tables of its type
        * Keep stores as small - as few strings as possible (map strings to an ID in a separate table)
        * Row key is a combination of JVM ID and date (20130628 for 28th June 2013)
        * There should be a upper threshold for number of days for which 'raw' data is stored would be, say 1 month (30 days)
        * Following are the roll-up tables to be created alongwith
                - Hourly Roll-up:  For 2 months  => 24 * 60 = 1440 columns. One row per JVM
                - Daily Roll-up:   For 6 months  => 180 columns. One row per JVM
                - Weekly Roll-up:  For 50 weeks  => 50 columns. One row per JVM
                - Monthly Roll-up: For 24 months => 24 columns. One row per JVM
        * All the inserts into the Roll-up table should have a TTL (per above table)

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

2. Keyspace

    CREATE KEYSPACE JvmMetrics WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};
    CREATE KEYSPACE JvmThreadMetrics WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};
    CREATE KEYSPACE JvmMemoryMetrics WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};
    CREATE KEYSPACE JvmDataSourceMetrics WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};
    CREATE KEYSPACE JvmMethodMetrics WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

3. Tables (Column Families)

    JvmMetrics KEYSPACE
    -------------------

    CREATE TABLE JvmMetricsRaw (
      jvm_id int,
      date varchar,
      ts timestamp,                   // int - time of day instead of timestamp
      total_started_threads bigint,   // useless
      total_live_threads int,         // rename
      total_daemon_threads int,       // useless
      total_peak_threads int,         // useless
      PRIMARY KEY (jvm_id, date)
    );

        Roll-up tables
        ~~~~~~~~~~~~~~
            CREATE TABLE JvmMetricsHourly (
                        jvm_id int,
                        hour int,
                        live_threads_counter int,
                        live_threads_avg float,
                        PRIMARY KEY (jvm_id)
                      );

            CREATE TABLE JvmMetricsDaily (
                        jvm_id int,
                        day int,
                        total_started_threads bigint,
                        total_live_threads int,
                        total_daemon_threads int,
                        total_peak_threads int,
                        PRIMARY KEY (jvm_id)
                      );

            CREATE TABLE JvmMetricsWeekly (
                        jvm_id int,
                        week int,
                        total_started_threads bigint,
                        total_live_threads int,
                        total_daemon_threads int,
                        total_peak_threads int,
                        PRIMARY KEY (jvm_id)
                      );

            CREATE TABLE JvmMetricsMonthly (
                        jvm_id int,
                        month int,
                        total_started_threads bigint,
                        total_live_threads int,
                        total_daemon_threads int,
                        total_peak_threads int,
                        PRIMARY KEY (jvm_id)
                      );

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

    JvmThreadMetrics KEYSPACE  - Are there any usecases which support the collection of this metric? Else, drop the whole thing.
    -------------------------

    CREATE TABLE JvmThreadMetricsRaw (
          jvm_id int,
          date varchar,
          ts timestamp,
          thread_id bigint,
          thread_name varchar,
          lock_name varchar,
          lock_owner_id int,
          lock_owner_name varchar,
          blocked_count int,
          blocked_time int,
          waited_count int,
          waited_time int,
          is_suspended boolean,
          PRIMARY KEY (jvm_id, date)
        );

    CREATE INDEX jvm_thread_name ON JvmThreadMetricsRaw (thread_name);
    CREATE INDEX jvm_thread_id ON JvmThreadMetricsRaw (thread_id);

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

    JvmMemoryMetrics KEYSPACE
    -------------------------

    * Code Cache, Eden Space, Tenured, Perm, Survivor - collect every 10 minutes
    * Heap and Non-Heap - collect every minute
    * Should the Heap Memory table ALSO contain the thread count - the JvmMetrics table, with only thread-count as
        its data point is probably TOO MUCH meta for very little data

    CREATE TABLE JvmHeapMemoryMetricsRaw (
              jvm_id int,
              date varchar,
              ts timestamp,
              committed bigint,
              max bigint,
              used bigint,
              PRIMARY KEY (jvm_id, date)
            );

    CREATE TABLE JvmNonHeapMemoryMetricsRaw (
              jvm_id int,
              date varchar,
              ts timestamp,
              committed bigint,
              max bigint,
              used bigint,
              PRIMARY KEY (jvm_id, date)
            );

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

    JvmDataSourceMetrics KEYSPACE
    -----------------------------

    * how big is the data-source name?
    * if data-source string is big, then, instead of storing big strings for index - use data-source-ID
    * Should data-source be collected every minute? Maybe 2-minutes is not bad after all - brings down the cost of collection
        on the agent side as well

    CREATE TABLE JvmDataSourceMetricsRaw (
                  jvm_id int,
                  date varchar,
                  ts timestamp,
                  datasource_name varchar,
                  pool_size bigint,
                  free_pool_size bigint,
                  usetime bigint,
                  PRIMARY KEY (jvm_id, date)
                );

    CREATE INDEX jvm_datasource_name ON JvmDataSourceMetricsRaw (datasource_name);

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

    JvmMethodMetrics KEYSPACE
    -------------------------

    * keep a separate table for mapping method ID to Name

    Raw Trend Query Tables
    ~~~~~~~~~~~~~~~~~~

    CREATE TABLE JvmMethodIdNameMap (
                          jvm_id int,
                          method_id bigint,
                          method_name varchar,
                          PRIMARY KEY (jvm_id)
                        );

    CREATE TABLE JvmMethodMetricsRaw (
                      jvm_id int,
                      date varchar,
                      ts timestamp,
                      method_id bigint,
                      invocations bigint,
                      response_time bigint,
                      PRIMARY KEY (jvm_id, date)
                    );

    CREATE INDEX jvm_method_name ON JvmMethodMetricsRaw (method_id);

    Trend Query Roll-up Tables
    ~~~~~~~~~~~~~~


    TopN Query Tables
    ~~~~~~~~~~~~~~~~~

    * data in these tables is kept sorted by maximum (response-time/invocations) to minimum
    * is a minute-wise table required in this case?

    CREATE TABLE JvmMethodTrendResponseTimeHourly (
        jvm_id int,
        method_id bigint,
        hour int,
        response_time float
    );

    CREATE TABLE JvmMethodTrendInvocationHourly (
        jvm_id int,
        method_id bigint,
        hour int,
        invocations bigint
    );

    CREATE TABLE JvmMethodTrendResponseTimeDaily (
    );

    CREATE TABLE JvmMethodTrendInvocationDaily (
    );

    CREATE TABLE JvmMethodTrendResponseTimeWeekly (
    );

    CREATE TABLE JvmMethodTrendInvocationWeekly (
    );

    CREATE TABLE JvmMethodTrendResponseTimeMonthly (
    );

    CREATE TABLE JvmMethodTrendInvocationMonthly (
    );


    Queries
    ~~~~~~~

    1) last one hour, which methods among {A, B, C or *} took the most response_time?
    2) trend queries - column slice over a time range
    3)

